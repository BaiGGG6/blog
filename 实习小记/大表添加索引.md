# 大表添加索引

## 前言：
- 在实习中有遇到此类问题，比较有意思，则进行一篇记录
- 对于我们的update，insert，delete等操作，mysql都会对表进行加锁(表锁或者行锁)，严重的可能造成业务直接宕机
- 在未添加索引的表中，当我们的单表数据量到达了百万级别，一些sql的操作就会开始缓慢
- 若我们要在这张达到百万级的大表中，直接添加索引，则会导致当前大表直接锁死，造成业务受到影响
- 对于问题的排查，第一时间我们应该要做的是恢复业务，然后保留现场文件，最后才是排查原因

## 术语解释：
1. 影子策略：在此处是一种对mysql进行操作的策略，主要是通过拷贝一张新表代替旧表的思路

2. 索引：一种提升数据库查询的数据结构

3. 主从：数据库的一种集群模式，保证数据库的高可用

## 具体过程：
tips: 此处是做停机处理的，务必做好**数据备份**!!

思路：使用用影子策略进行解决，当前我们这表中是少添加了索引，所以我们对对应的表结构拷贝一份，再对新表添加上所需要的索引，再进行数据的拷贝即可

1. 首先将目标表进行拷贝
```
create table test_table_copy like test_table;
```

2. 对新表添加上对应的索引
```
create index IF NOT EXISTS index_demo_idx on test_table(text);
```

3. 将旧表改名
```
rename test_table to test_table_history;
```

4. 将旧表数据拷贝到新表
```
insert into test_table_copy select * from evidence_task_history;
```

5. 若旧表`select * from evidence_task_history`数据过大，一次性导入失败，则我们可以考虑以时间(也可以是其他进行切分)进行分批导入
```
insert into test_table_copy select * from evidence_task_history where create_time <= '2022-01-01 00:00:00';
```

6. 将新表改名为业务所需表
```
rename test_table_copy to test_table;
```

7. 删除原表（自行选择，也可以如拓展里所说的一样）
```
drop table evidence_task_history;
```

## 拓展：
- **单表运行时：** 哪需要对当前的情况进行判断是否可以，若当前表是一张只增不改不删的表，哪我们可以通过上述的操作，直接进行线上处理，只需要注意新表的自增id是否是按旧表之后的开始即可
- **主从多表运行时：** 例如一主二从，可以先对slave1把流量切掉，再添加索引，添加完再挂上，等待和主数据库同步完成，再让slave2同步以上操作，最后将slave1设置为主库，再将原主库进行以上操作即可.
- **表实在过大：** 当一张表实在过大，其实我们可以在数据更新的时候，将旧表的数据按时间(或者其他进行拆分)进行一个分表，在我们的逻辑里面按拆分条件选择对新表还是旧表进行查询
- 人觉得在这个旧表数据拷贝新表的过程，其实可以做一定的数据清洗，对数据进行筛选添加到新表